<!DOCTYPE html>
<html>
	<head>
		<title> WebRoutes </title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="libs/leaflet/leaflet.css" />
		<link rel="stylesheet" href="styles.css">
	</head>
	<body>

	 	<div id="map"></div>
	 	<div id="nfo">
	 		welcome to WebRoutes!<br>
	 		To "visit" a website is to request a copy of that website's source code files to be broken up into smaller packets and sent from a server (located somewhere in the world) to your browser where it is reconstructed and rendered. The routes these packets take are rarely a straight line from a server to your browser, and tracing these routes reveals a set of interests and influences based on the Internet's peculiar geopolitical situation.<br><br>
	 		type a URL into the address bar of the browser below to chart the path that website takes to get from it's server to your computer 
	 	</div>
		
		<script src="app.js"></script>
		<script src="libs/leaflet/leaflet.js"></script>
		<script src="libs/turf.min.js"></script>	
		<script>


			// NODE WEBKIT STUFFS -----------------------------------------------------------------
			// ------------------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------

			var nw			= require('nw.gui');
			var win 		= nw.Window.get();
			win.showDevTools();


			// LEAFLET JS OVERRIDES !!! -----------------------------------------------------------
			// ------------------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------

			L.Map.prototype._animateZoom = function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {
				if (!forTouchZoom) { this._animatingZoom = true; }
				L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
				this._animateToCenter = center;
				this._animateToZoom = zoom;
				if (L.Draggable) { L.Draggable._disabled = true; }
				L.Util.requestAnimFrame(function () {
					this.fire('zoomanim', {
						center: center,
						zoom: zoom,
						origin: origin,
						scale: scale,
						delta: delta,
						backwards: backwards
					});
					// EDITED THIS IN ORDER TO HAVE CONTROL OVER ZOOM TIME
					// BECAUSE ITS NOT EXPOSED IN THE LEAFLET API
					setTimeout(L.bind(this._onZoomTransitionEnd, this), 1500); //<<< NICK's EDIT
				}, this);
			}

			L.Map.prototype.panBy = function (offset, options) {
				offset = L.point(offset).round();
				options = options || {};
				// THIS PREVENTS PANNING IF NEW DESTINATION ISN'T IN FRAME, WTF?!
				// LETS GET RID OF THIS SO WE CAN SMOOTH PAN TO ANYWHERE WE WANT
				// if (!offset.x && !offset.y) { return this; }
				// ^ NICK'S EDIT 
				if (!this._panAnim) {
					this._panAnim = new L.PosAnimation();
					this._panAnim.on({ 'step': this._onPanTransitionStep, 'end': this._onPanTransitionEnd }, this);
				}
				if (!options.noMoveStart) { this.fire('movestart'); }
				if (options.animate !== false) {
					L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');
					var newPos = this._getMapPanePos().subtract(offset);
					this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
				} else {
					this._rawPanBy(offset);
					this.fire('move').fire('moveend');
				}
				return this;
			}			


			// INFO MODAL -------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------

			var NFO = {
				ele: document.getElementById('nfo'),
				initTxt: document.getElementById('nfo').innerHTML,
				update: function( txt ){
					var self = this;
					this.ele.style.background = "#fff";
					this.ele.innerHTML = txt;
					setTimeout(function(){
						self.ele.style.background = "#000";
					},500);
				},
				reset: function(){
					this.ele.innerHTML = this.initTxt;
				}
			};


			// TRACER OBJECT ( handles trace route logic/drawing ) --------------------------------
			// ------------------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------

			var tracer = {			
				running: false,			// trace route animation is running	
				myip: false,			// true once "my ip" has been received				
				holds:[],				// hold hops until "my ip" is received
				hops: [],				// hop data collection ( starting with "my ip" )
				pulseNodes: [], 		// collection of pulsing svg circles ( start/end nodes )
				modals: [],				// collection of node popup modals
				queued: 0,				// how many of the hops have already been drawn
				complete: false,		// true when trace complete fired
				animInProgress: false,	// true when an animation is in progress
				timers: [],				// collect setTimeouts in order to clear them in abort
				// Internet infrastructure .....................................
				cables: null,// drawn path
				cableGeoJson:null,
				exchangesGeoJson:null,
				styles: {
					pulse: {
						"radius": 5,
						"color": '#fff',
						"opacity":1.0,
						"weight" : 2,
						"fillColor": '#fff',
						"fillOpacity": 0,
					},
					dot: {
						"radius": 5,
						"color": '#fff',
						"opacity":1,
						"weight" : 2,
						"fillColor": '#fff',
						"fillOpacity": 1,
					},
					path: {
						"color": '#fff',
						"opacity":1.0,
						"weight":2
					},
					cables: {
						"color": "#fff",
						"weight": 1,
						"opacity": 0.5,
						"fillOpacity": 0,
						"radius": 3
					}
				},
				// ---------------------------------
				// --------------------------------------------------------- utils ------------
				// ---------------------------------------------------------------
				norm: function(value, min, max) {
					return (value - min) / (max - min);
				},
				lerp: function(norm, min, max) {
					return (max - min) * norm + min;
				},
				map: function(value, sourceMin, sourceMax, destMin, destMax) {
					return this.lerp(this.norm(value, sourceMin, sourceMax), destMin, destMax);
				},
				// fadeIn / fadeOut 
				// via: http://www.chrisbuttery.com/articles/fade-in-fade-out-with-javascript/
				fadeIn: function(el, display){
					el.style.opacity = 0;
					//el.style.display = display || "block";
					(function fade() {
						var val = parseFloat(el.style.opacity);
						if (!((val += .025) > 1)) {
							el.style.opacity = val;
							requestAnimationFrame(fade);
						}
					})();
				},
				fadeOut: function(el ){
					el.style.opacity = 1;
					(function fade() {
						if ((el.style.opacity -= .025) < 0) {
							//el.style.display = "none";
						} else {
							requestAnimationFrame(fade);
						}
					})();
				},
				// ---------------------------------
				// --------------------------------------------------------- draw leaflet -----
				// ---------------------------------------------------------------
				drawCables: function( data, bound ){					
					if(!this.cableGeoJson) this.cableGeoJson = data;
					// draw cables
					this.cables = L.geoJson(data,{style:this.styles.cables}).addTo(map);
					// label svg <g> elements that are cables ( && thus not to be removed )
					var parent = map._panes.overlayPane.children[0]; // <svg>
					for (var i = 0; i < parent.children.length; i++) {	
						parent.children[i].setAttribute('name','internet'); // <g> 
					}
					// fit bounds	
					if( bound ){
						map.setMaxBounds(this.cables.getBounds());
						map.fitBounds(this.cables.getBounds());
						map.panInsideBounds(this.cables.getBounds());
					}				
				},	
				drawExchanges: function( data ){
					if(!this.exchangesGeoJson) this.exchangesGeoJson = data;
					// draw exchanges
					var scale = this.map( map.getZoom(), 3, 6, 0.5, 0.125 );
					for (var i = 0; i < data.features.length; i++) {
						var coords = data.features[i].geometry.coordinates;
						var circ = [ coords[1], coords[0] ];
						var line1 = [
							[ coords[1]-scale, coords[0]-scale ],
							[ coords[1]+scale, coords[0]+scale ]
						];
						var line2 = [
							[ coords[1]+scale, coords[0]-scale ],
							[ coords[1]-scale, coords[0]+scale ]
						];						
						this.styles.cables.radius = map.getZoom();
						L.circleMarker( circ, this.styles.cables ).addTo(map);
						L.polyline( line1, this.styles.cables ).addTo(map);
						L.polyline( line2, this.styles.cables ).addTo(map);
					}
					// label svg <g> elements that are cables ( && thus not to be removed )
					var parent = map._panes.overlayPane.children[0]; // <svg>
					for (var i = 0; i < parent.children.length; i++) {	
						parent.children[i].setAttribute('name','internet'); // <g> 
					}
				},	
				drawNode: function( hop, kind ){
					var geo = [hop.geo.lat,hop.geo.lon];
					// draw dot					
					var dot = L.circleMarker( geo, this.styles.dot ).addTo(map);
					// if "pulse", also draw the pulses
					if( kind == "pulse" ){
						this.styles.pulse.radius = 5;
						var pulse1 = L.circleMarker( geo, this.styles.pulse ).addTo(map);
						this.pulseNodes.push( pulse1 );
						this.styles.pulse.radius = 10;
						var pulse2 = L.circleMarker( geo, this.styles.pulse ).addTo(map);
						this.pulseNodes.push( pulse2 );												
					}				
				},					
				drawPath: function( s, e ){
					var self = this;
					// draw latest path
					// var s = this.hops[this.queued-1];
					// var e = this.hops[this.queued];
					var p = [ [s.geo.lat,s.geo.lon], [e.geo.lat,e.geo.lon] ];
					L.polyline(p, this.styles.path).addTo(map);
										
					// animate path...			
					var parent = map._panes.overlayPane.children[0]; // <svg>					  
					var g = parent.children[ parent.children.length-1 ]; // last <g>
					var path = g.children[0]; // <path>
					var length = path.getTotalLength();

					// animation code below via: https://jakearchibald.com/2013/animated-line-drawing-svg/
					// Clear any previous transition
					path.style.transition = path.style.WebkitTransition = 'none';
					// Set up the starting positions
					path.style.strokeDasharray = length + ' ' + length;
					path.style.strokeDashoffset = length;
					// Trigger a layout so styles are calculated & the browser
					// picks up the starting position before animating
					path.getBoundingClientRect();
					// Define our transition
					path.style.transition = path.style.WebkitTransition = 'stroke-dashoffset 2s';
					//'stroke-dashoffset 2s ease-in-out';
					// Go!
					path.style.strokeDashoffset = '0';	
				},
				redrawInternet: function(){
					// remove Internet 
					var parent = map._panes.overlayPane.children[0]; // <svg>
					var toRemove = [];
					for (var i = 0; i < parent.children.length; i++) {	
						if( parent.children[i].getAttribute('name') === "internet" )
							toRemove.push( parent.children[i] );
					}
					for (var j = 0; j < toRemove.length; j++) parent.removeChild( toRemove[j] );
					// redraw Internet
					this.drawCables( this.cableGeoJson );
					this.drawExchanges( this.exchangesGeoJson );
				},
				redrawRoute: function(){
					// ...nothing yet, possibly use this space to redraw paths that are 
					// cut short due to new zoom level ( given the path length had been
					// calculated at a different zoom level )
				},
				// ---------------------------------
				// --------------------------------------------------------- animation logic --
				// ---------------------------------------------------------------
				animateStart: function( hop ){
					var self = this;
					this.animInProgress = true;
					this.drawNode( hop, "pulse" );
					NFO.update('this is your request, originating in '+ 
						`${hop.city+", "}${hop.region+", "}${hop.country}` );
					var t = setTimeout(function(){
						self.fadeOut(  map._panes.tilePane );
						NFO.update('this is the Internet');
					},4000);
					this.timers.push( t );
					
					var t = setTimeout(function(hop){
						map.setView( [hop.geo.lat, hop.geo.lon], 6 );
					},7000,hop);
					this.timers.push( t );

					var t = setTimeout(function(){
						self.fadeIn(  map._panes.tilePane );
					},9000);
					this.timers.push( t );

					var t = setTimeout(function(){
						self.animInProgress = false;
						self.queued++;
					},10000);					
					this.timers.push( t );
				},
				animateHop: function( start, hop ){
					var self = this;					
					this.animInProgress = true;
					this.drawPath( start, hop );
					this.drawNode( hop );
					var txt;
					if( hop.kind=="*" ) txt = `hop #${this.queued} missing information`;
					else txt = `hop #${this.queued} to ${hop.city+", "}${hop.region+", "}${hop.country} <br>`+
						`Internet service provided by ${hop.isp}`;					
					NFO.update(txt);
					map.panTo([hop.geo.lat, hop.geo.lon],{duration:2});
					var t = setTimeout(function(){
						self.animInProgress = false;
						self.queued++;
					},4000);
					this.timers.push( t );

				},
				animateEnd: function(){
					var self = this;
					this.animInProgress = true;
					var start = this.hops[0];
					var hop = this.hops[this.hops.length-1];
					this.drawNode( hop, "pulse" );
					var txt = (hop.isp==hop.org) ? 
						`website files located in ${hop.city+", "}${hop.region+", "}${hop.country} <br>`+
						`hosted by ${hop.org}` :
						`website files located in ${hop.city+", "}${hop.region+", "}${hop.country} <br>`+
						`hosted by ${hop.org}`+
						`Internet service provided by ${hop.isp}`;
					NFO.update(txt);
					self.fadeOut(  map._panes.tilePane );
					var arr = [];
					for (var i = 0; i < this.hops.length; i++){ 
						if( this.hops[i].kind !=="*")
							arr.push( [this.hops[i].geo.lat,this.hops[i].geo.lon] );
					}
					var fullpath = L.polyline( arr );
					var t = setTimeout(function(){
						map.fitBounds(fullpath.getBounds());
						var txt = `this is the route the website took to get from ${start.city+", "}${start.region+", "}${start.country} to ${hop.city+", "}${hop.region+", "}${hop.country}`;
						NFO.update(txt);
					},4000);	
					this.timers.push( t );

					var t = setTimeout(function(){
						self.fadeIn( map._panes.tilePane );
					},8000);	
					this.timers.push( t );

					var t = setTimeout(function(){
						self.reset();						
					},10000);		
					this.timers.push( t );			
				},				
				// ---------------------------------
				// --------------------------------------------------------- core -------------
				// ---------------------------------------------------------------
				addNode: function( geo, kind ){
					this.running = true;

					var hop = {
						kind: kind,
						city: geo.city,
						region: geo.regionName,
						country: geo.countryCode,
						isp: geo.isp,
						org: geo.org,
						geo: { lat: geo.lat, lon: geo.lon }
					};		

					if( kind=="*" ) {
						if(this.myip) hop.geo = this.hops[this.hops.length-1].geo;
						else hop.geo = this.holds[this.holds.length-1].geo;
					}

					// queue logix
					if( (kind=="hop"||kind=="*") && !this.myip ){
						this.holds.push( hop );
					} else if( (kind=="hop"||kind=="*") && this.myip ){
						this.hops.push( hop );
					} else if( kind=="start" ){
						this.myip = true;
						this.hops.push( hop );
						for (var i = 0; i < this.holds.length; i++) {
							this.hops.push( this.holds[i] );
						}
					}		
				},
				handleTimeout: function(){
					var toRemove = [];
					for (var i = this.hops.length-1; i >= 0; i--) {
						if( this.hops[i].kind=="*" ) toRemove.push( i );
						// else break;
					}
					for (var j = 0; j < toRemove.length; j++) this.hops.splice(toRemove[j],1);
				},
				abort: function(){
					for (var i = 0; i < this.timers.length; i++) {
						clearTimeout( this.timers[i] );
					}
					this.reset();
				},
				reset: function(){
					// reset properties
					this.myip = false;
					this.holds = [];
					this.hops = [];
					this.pulseNodes = [];
					this.modals = [];
					this.queued = 0;
					this.complete = false;
					this.animInProgress = false;
					// remove drawn nodes from map svg layer
					var parent = map._panes.overlayPane.children[0]; // <svg>
					var toRemove = [];
					for (var i = 0; i < parent.children.length; i++) {	
						if( parent.children[i].getAttribute('name') !== "internet" )
							toRemove.push( parent.children[i] );
					}
					for (var j = 0; j < toRemove.length; j++) parent.removeChild( toRemove[j] );	
					// reset nfo copy
					NFO.reset();
					// make sure map is faded in
					map._panes.tilePane.style.opacity = 1;
					// re position map
					map.setView([0,0],3);	
					// every this reset...
					this.running = false;	
				},
				update: function(){
					// pulse nodes
					for (var i = 0; i < this.pulseNodes.length; i++) {
						var r = (this.pulseNodes[i].options.radius>20) ? 5 : this.pulseNodes[i].options.radius+0.1;
						var o = this.map( r, 5, 20, 1, 0 );
						this.pulseNodes[i].setRadius( r );
						this.pulseNodes[i].setStyle({opacity:o});
					}
					// check queue
					if( this.hops.length > this.queued && !this.animInProgress ){
						var s = this.hops[ this.queued-1 ];
						var e = this.hops[ this.queued ];
						if(this.queued==0) this.animateStart( e );
						else this.animateHop( s, e );	
					} else if( this.hops.length!==0 && this.hops.length==this.queued && this.complete ){
						this.complete = false;
						this.animateEnd();
					}
				}
			}

			// INIT && EVENTS ---------------------------------------------------------------------
			// ------------------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------


			var map = L.map('map',{ 
				maxZoom:6, 
				minZoom:3, 
				zoomControl:false, 
				attributionControl: false
			}).setView([0,0], 3);

			var ourmap = L.tileLayer('http://localhost:3001/map/{z}/{x}/{y}.png').addTo(map);
			// var ourmap = L.tileLayer('https://a.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

			// -------------------------- animation loop for triggering tracer.update()
			function animLoop(){
				requestAnimationFrame( animLoop );
				tracer.update();
			} animLoop();


			map.on('zoomend',function(){
				tracer.redrawInternet();
				tracer.redrawRoute();
			});


			// -------------------------- INIT DRAW CABLES 
			var req = new XMLHttpRequest();
			req.open("GET", 'maps/cable-data.json', true);
			// req.open("GET", 'telegeography-data/new-cable-data.json', true);
			req.addEventListener("load", function() {
				var data = JSON.parse( req.responseText ); 
				tracer.drawCables( data, true );
			});
			req.send(null);
			// -------------------------- INIT DRAW EXCHANGES 
			var req1 = new XMLHttpRequest();
			req1.open("GET", 'maps/buildings.geojson', true);
			req1.addEventListener("load", function() {
				var data = JSON.parse( req1.responseText ); 
				tracer.drawExchanges( data );
			});
			req1.send(null);

 			// -------------------------- DRAW TRACEROUTE EVENTS
 			
 			emitter.on("trace started", function(){
				// if new trace starts but old one still animating	
 				if( tracer.running ) tracer.abort();
 			});

 			emitter.on("trace hop", function(hop){ 	
 				if( hop.ip=="*") console.log('got one!',hop);
 				if( hop.geo ) 			tracer.addNode( hop.geo, "hop" ); 				
 				else if( hop.ip=="*" ) 	tracer.addNode( {}, "*" ); 				
 			});

 			emitter.on("my ip", function(hop){
 				console.log('fired!',hop);
 				tracer.addNode( hop.geo, "start" );
 			});

 			emitter.on("trace complete", function(hop){ 
 				tracer.complete = true;
 			});

 			emitter.on("trace timeout", function(){ 
 				tracer.handleTimeout();
 				tracer.complete = true;
 			});


 			emitter.on("trace cancelled", function(){
 				console.log('trace cancelled');
 				tracer.abort();
 			});
 			
 			
 			emitter.on("trace error", function(){ 
 				console.log('trace error');
 				tracer.abort();
 			});


			// DEBUG STUFF ------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------
			// ------------------------------------------------------------------------------------


			function ranTest(){
				var lat = Math.random()*20;
				var lon = Math.random()*20;
				var geo = { lat:lat, lon:lon };
				return geo;
			}


			var myIcon = L.icon({
			    iconUrl: 'icon-96.png.png',
			    iconSize: [38, 95],
			    iconAnchor: [22, 94]
			});


			document.body.addEventListener('keydown',function(e){
				switch(e.key){
					case "h" : tracer.addNode( ranTest(), "hop" ); break;
					case "s" : tracer.addNode( ranTest(),"start"); break;
					case "e" : tracer.animateEnd(); break;
					case "z" : map.zoomIn(1); break;
					case "x" : map.zoomOut(1); break;
					case "r" : tracer.reset(); break;
				}
			});



			// NOTES:::::
			/*
				https://github.com/brannondorsey/ProbeKit/blob/master/public/habitat/map-iframe.html
				http://leafletjs.com/examples/quick-start.html
				
				https://github.com/telegeography/www.submarinecablemap.com
				http://www.internetexchangemap.com/
				http://submarinecablemap.com/
				
				http://jsfiddle.net/mihaibirsan/Wzvre/

				TODO ::::::
				look into why some pan's don't pan still && lines to nowhere 
				( re-render CSS paths on zoom event )

			*/	

		</script>

	</body>
</html>

